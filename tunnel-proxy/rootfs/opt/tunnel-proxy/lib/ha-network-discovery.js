/**
 * Home Assistant ÁΩëÁªúÂèëÁé∞Ê®°Âùó
 * ‰ΩøÁî®Â§öÁßçÊñπÊ≥ïÊô∫ËÉΩÊâ´ÊèèÂ±ÄÂüüÁΩë‰∏≠ÁöÑ Home Assistant ÂÆû‰æã
 */

const os = require('os');
const http = require('http');
const https = require('https');
const { execSync } = require('child_process');
const Logger = require('./logger');

class HANetworkDiscovery {
  constructor() {
    this.discoveredHosts = new Map(); // Â≠òÂÇ®ÂèëÁé∞ÁöÑ‰∏ªÊú∫‰ø°ÊÅØ
    this.scanResults = [];
    this.commonPorts = [8123, 8443, 443, 80, 3000, 8080, 8000];
    this.haIndicators = [
      'Home Assistant',
      'hass',
      'homeassistant',
      'hassio',
      'supervisor'
    ];
  }

  /**
   * ‰∏ªË¶ÅÁöÑÂèëÁé∞ÊñπÊ≥ï - ÁªÑÂêàÂ§öÁßçÊâ´ÊèèÊäÄÊúØ
   */
  async discoverHomeAssistant() {
    Logger.info('üîç ÂºÄÂßãÊô∫ËÉΩÊêúÁ¥¢Â±ÄÂüüÁΩë‰∏≠ÁöÑ Home Assistant ÂÆû‰æã...');

    const results = {
      discovered: [],
      methods: {
        networkScan: [],
        mDNS: [],
        commonHosts: [],
        ping: []
      },
      recommendedHost: null,
      scanTime: Date.now()
    };

    // Âπ∂Ë°åÊâßË°åÂ§öÁßçÂèëÁé∞ÊñπÊ≥ï
    try {
      const [networkHosts, mDNSHosts, commonHosts, pingHosts] = await Promise.allSettled([
        this.scanLocalNetwork(),
        this.discoverViaMDNS(),
        this.checkCommonHosts(),
        this.pingKnownHosts()
      ]);

      // Êî∂ÈõÜÊâÄÊúâÁªìÊûú
      if (networkHosts.status === 'fulfilled') {
        results.methods.networkScan = networkHosts.value;
      }
      if (mDNSHosts.status === 'fulfilled') {
        results.methods.mDNS = mDNSHosts.value;
      }
      if (commonHosts.status === 'fulfilled') {
        results.methods.commonHosts = commonHosts.value;
      }
      if (pingHosts.status === 'fulfilled') {
        results.methods.ping = pingHosts.value;
      }

      // ÂêàÂπ∂ÂíåÂéªÈáçÁªìÊûú
      const allHosts = [
        ...results.methods.networkScan,
        ...results.methods.mDNS,
        ...results.methods.commonHosts,
        ...results.methods.ping
      ];

      results.discovered = this.deduplicateAndRank(allHosts);
      results.recommendedHost = this.selectBestHost(results.discovered);

      Logger.info(`‚úÖ ÂèëÁé∞ ${results.discovered.length} ‰∏™ÂèØËÉΩÁöÑ Home Assistant ÂÆû‰æã`);
      if (results.recommendedHost) {
        Logger.info(`üéØ Êé®Ëçê‰ΩøÁî®: ${results.recommendedHost.host}:${results.recommendedHost.port}`);
      }

      return results;

    } catch (error) {
      Logger.error(`ÁΩëÁªúÂèëÁé∞ËøáÁ®ãÂá∫Èîô: ${error.message}`);
      return results;
    }
  }

  /**
   * Êâ´ÊèèÊú¨Âú∞ÁΩëÁªúÊÆµ
   */
  async scanLocalNetwork() {
    Logger.info('üì° Êâ´ÊèèÊú¨Âú∞ÁΩëÁªúÊÆµ...');
    const hosts = [];

    try {
      const networkInterfaces = this.getLocalNetworkRanges();

      for (const range of networkInterfaces) {
        Logger.info(`üîç Êâ´ÊèèÁΩëÊÆµ: ${range.network}`);
        const rangeHosts = await this.scanNetworkRange(range);
        hosts.push(...rangeHosts);
      }

    } catch (error) {
      Logger.warn(`ÁΩëÁªúÊâ´ÊèèÂ§±Ë¥•: ${error.message}`);
    }

    return hosts;
  }

  /**
   * Ëé∑ÂèñÊú¨Âú∞ÁΩëÁªúËåÉÂõ¥
   */
  getLocalNetworkRanges() {
    const ranges = [];
    const interfaces = os.networkInterfaces();

    for (const [name, addrs] of Object.entries(interfaces)) {
      if (!addrs) continue;

      for (const addr of addrs) {
        if (addr.family === 'IPv4' && !addr.internal && addr.address !== '127.0.0.1') {
          const network = this.calculateNetworkRange(addr.address, addr.netmask);
          if (network) {
            ranges.push({
              interface: name,
              network: network,
              gateway: addr.address
            });
          }
        }
      }
    }

    return ranges;
  }

  /**
   * ËÆ°ÁÆóÁΩëÁªúËåÉÂõ¥
   */
  calculateNetworkRange(ip, netmask) {
    try {
      const ipParts = ip.split('.').map(Number);
      const maskParts = netmask.split('.').map(Number);

      // ËÆ°ÁÆóÁΩëÁªúÂú∞ÂùÄ
      const networkParts = ipParts.map((part, i) => part & maskParts[i]);

      // ËÆ°ÁÆóÂπøÊí≠Âú∞ÂùÄ
      const broadcastParts = networkParts.map((part, i) => part | (255 - maskParts[i]));

      // ËÆ°ÁÆó CIDR
      const cidr = maskParts.reduce((acc, part) => {
        return acc + part.toString(2).split('1').length - 1;
      }, 0);

      return {
        network: `${networkParts.join('.')}.0`,
        broadcast: broadcastParts.join('.'),
        cidr: cidr,
        range: `${networkParts.join('.')}.1-${broadcastParts.join('.')}`
      };
    } catch (error) {
      Logger.warn(`ËÆ°ÁÆóÁΩëÁªúËåÉÂõ¥Â§±Ë¥•: ${error.message}`);
      return null;
    }
  }
  /**
   * Êâ´ÊèèÁΩëÁªúËåÉÂõ¥ÂÜÖÁöÑ‰∏ªÊú∫
   */
  async scanNetworkRange(networkInfo) {
    const hosts = [];

    try {
      // ‰øÆÂ§çÔºöÊ≠£Á°ÆÂ§ÑÁêÜÁΩëÁªú‰ø°ÊÅØÂØπË±°
      const networkStr = typeof networkInfo.network === 'string' ?
        networkInfo.network :
        `${networkInfo.network.network || '192.168.1.0'}`;

      const baseIP = networkStr.substring(0, networkStr.lastIndexOf('.'));

      // Âπ∂ÂèëÊâ´ÊèèÂ∏∏ËßÅÁöÑ‰∏ªÊú∫Âú∞ÂùÄ
      const scanPromises = [];
      const commonLastOctets = [1, 2, 100, 101, 102, 150, 170, 200, 254]; // Â∏∏ËßÅÁöÑË∑ØÁî±Âô®ÂíåËÆæÂ§áIP

      for (const octet of commonLastOctets) {
        const targetIP = `${baseIP}.${octet}`;
        scanPromises.push(this.checkHostForHA(targetIP));
      }

      // Á≠âÂæÖÊâÄÊúâÊâ´ÊèèÂÆåÊàê
      const results = await Promise.allSettled(scanPromises);

      for (const result of results) {
        if (result.status === 'fulfilled' && result.value) {
          hosts.push(result.value);
        }
      }
    } catch (error) {
      Logger.warn(`Êâ´ÊèèÁΩëÁªúËåÉÂõ¥Â§±Ë¥•: ${error.message}`);
    }

    return hosts;
  }

  /**
   * ÈÄöËøá mDNS/Bonjour ÂèëÁé∞ÊúçÂä°
   */
  async discoverViaMDNS() {
    Logger.info('üåê ÈÄöËøá mDNS/Bonjour ÂèëÁé∞ÊúçÂä°...');
    const hosts = [];

    try {
      // Â∞ùËØï‰ΩøÁî®Á≥ªÁªüÂëΩ‰ª§ÂèëÁé∞ mDNS ÊúçÂä°
      const services = await this.queryMDNSServices();

      for (const service of services) {
        if (this.isLikelyHomeAssistant(service.name) ||
          this.isLikelyHomeAssistant(service.type)) {

          const haHost = await this.checkHostForHA(service.host, service.port);
          if (haHost) {
            haHost.discoveryMethod = 'mDNS';
            haHost.serviceName = service.name;
            hosts.push(haHost);
          }
        }
      }

    } catch (error) {
      Logger.warn(`mDNS ÂèëÁé∞Â§±Ë¥•: ${error.message}`);
    }

    return hosts;
  }

  /**
   * Êü•ËØ¢ mDNS ÊúçÂä°
   */
  async queryMDNSServices() {
    const services = [];

    try {
      // ‰ΩøÁî®Á≥ªÁªüÂëΩ‰ª§Êü•ËØ¢ mDNS ÊúçÂä°
      if (process.platform === 'win32') {
        // Windows: Â∞ùËØï‰ΩøÁî® dns-sd ÂëΩ‰ª§
        try {
          const output = execSync('dns-sd -B _http._tcp', { timeout: 5000, encoding: 'utf8' });
          services.push(...this.parseDNSSDOutput(output));
        } catch (e) {
          Logger.warn('Windows mDNS Êü•ËØ¢Â§±Ë¥•ÔºåÂ∞ùËØïÂÖ∂‰ªñÊñπÊ≥ï');
        }
      } else {
        // Linux/macOS: ‰ΩøÁî® avahi-browse Êàñ dns-sd
        try {
          const output = execSync('avahi-browse -t _http._tcp', { timeout: 5000, encoding: 'utf8' });
          services.push(...this.parseAvahiOutput(output));
        } catch (e) {
          try {
            const output = execSync('dns-sd -B _http._tcp', { timeout: 5000, encoding: 'utf8' });
            services.push(...this.parseDNSSDOutput(output));
          } catch (e2) {
            Logger.warn('mDNS Êü•ËØ¢ÂëΩ‰ª§‰∏çÂèØÁî®');
          }
        }
      }

      // ÊâãÂä®Êü•ËØ¢Â∏∏ËßÅÁöÑ HA ÊúçÂä°Âêç
      const commonHAServices = [
        'homeassistant.local',
        'hassio.local',
        'hass.local',
        'ha.local'
      ];

      for (const serviceName of commonHAServices) {
        try {
          const resolved = await this.resolveMDNSName(serviceName);
          if (resolved) {
            services.push({
              name: serviceName,
              host: resolved.address,
              port: 8123,
              type: '_http._tcp'
            });
          }
        } catch (e) {
          // ÂøΩÁï•Ëß£ÊûêÂ§±Ë¥•
        }
      }

    } catch (error) {
      Logger.warn(`mDNS ÊúçÂä°Êü•ËØ¢Â§±Ë¥•: ${error.message}`);
    }

    return services;
  }

  /**
   * Ëß£Êûê mDNS ÂêçÁß∞Âà∞ IP Âú∞ÂùÄ
   */
  async resolveMDNSName(hostname) {
    return new Promise((resolve) => {
      try {
        const dns = require('dns');
        dns.lookup(hostname, { family: 4 }, (err, address) => {
          if (!err && address) {
            resolve({ address, hostname });
          } else {
            resolve(null);
          }
        });
      } catch (error) {
        resolve(null);
      }
    });
  }

  /**
   * Ê£ÄÊü•Â∏∏ËßÅ‰∏ªÊú∫Âú∞ÂùÄ
   */
  async checkCommonHosts() {
    Logger.info('üè† Ê£ÄÊü•Â∏∏ËßÅÁöÑ Home Assistant ‰∏ªÊú∫Âú∞ÂùÄ...');

    const commonHosts = [
      '127.0.0.1',
      'localhost',
      'homeassistant.local',
      'hassio.local',
      'hass.local',
      'ha.local',
      '192.168.1.100',
      '192.168.1.101',
      '192.168.1.200',
      '192.168.0.100',
      '192.168.0.101',
      '192.168.6.170', // ÂΩìÂâçÂ∑≤Áü•Âú∞ÂùÄ
      '172.30.32.2',   // Docker Â∏∏ËßÅÂú∞ÂùÄ
      '10.0.0.100',
      '10.0.0.101'
    ];

    const hosts = [];
    const checkPromises = commonHosts.map(host => this.checkHostForHA(host));

    const results = await Promise.allSettled(checkPromises);

    for (const result of results) {
      if (result.status === 'fulfilled' && result.value) {
        result.value.discoveryMethod = 'common-host';
        hosts.push(result.value);
      }
    }

    return hosts;
  }

  /**
   * Ping Â∑≤Áü•‰∏ªÊú∫
   */
  async pingKnownHosts() {
    Logger.info('üìç Ping Ê£ÄÊü•Â∑≤Áü•‰∏ªÊú∫...');

    const knownHosts = [
      '192.168.6.170',
      '192.168.1.170',
      '10.0.0.170'
    ];

    const hosts = [];

    for (const host of knownHosts) {
      try {
        const isAlive = await this.pingHost(host);
        if (isAlive) {
          const haHost = await this.checkHostForHA(host);
          if (haHost) {
            haHost.discoveryMethod = 'ping';
            hosts.push(haHost);
          }
        }
      } catch (error) {
        // ÂøΩÁï• ping Â§±Ë¥•
      }
    }

    return hosts;
  }

  /**
   * Ping ‰∏ªÊú∫Ê£ÄÊü•ËøûÈÄöÊÄß
   */
  async pingHost(host) {
    return new Promise((resolve) => {
      try {
        const ping = process.platform === 'win32' ? 'ping -n 1' : 'ping -c 1';
        execSync(`${ping} ${host}`, { timeout: 3000, stdio: 'ignore' });
        resolve(true);
      } catch (error) {
        resolve(false);
      }
    });
  }

  /**
   * Ê£ÄÊü•‰∏ªÊú∫ÊòØÂê¶ËøêË°å Home Assistant
   */
  async checkHostForHA(host, port = null) {
    const portsToCheck = port ? [port] : this.commonPorts;

    for (const checkPort of portsToCheck) {
      try {
        const result = await this.httpCheck(host, checkPort);
        if (result && this.isHomeAssistantResponse(result)) {
          return {
            host: host,
            port: checkPort,
            protocol: result.protocol,
            version: result.version,
            title: result.title,
            responseTime: result.responseTime,
            confidence: this.calculateConfidence(result),
            lastChecked: Date.now(),
            discoveryMethod: 'http-check'
          };
        }
      } catch (error) {
        // ÁªßÁª≠Ê£ÄÊü•‰∏ã‰∏Ä‰∏™Á´ØÂè£
      }
    }

    return null;
  }

  /**
   * HTTP Ê£ÄÊü•
   */
  async httpCheck(host, port) {
    const protocols = port === 443 || port === 8443 ? ['https', 'http'] : ['http', 'https'];

    for (const protocol of protocols) {
      try {
        const startTime = Date.now();
        const result = await this.makeHttpRequest(protocol, host, port);
        const responseTime = Date.now() - startTime;

        return {
          ...result,
          protocol: protocol,
          responseTime: responseTime
        };
      } catch (error) {
        // Â∞ùËØï‰∏ã‰∏Ä‰∏™ÂçèËÆÆ
      }
    }

    throw new Error(`Êó†Ê≥ïËøûÊé•Âà∞ ${host}:${port}`);
  }

  /**
   * ÂèëËµ∑ HTTP ËØ∑Ê±Ç
   */
  async makeHttpRequest(protocol, host, port) {
    return new Promise((resolve, reject) => {
      const httpModule = protocol === 'https' ? https : http;
      const timeout = 5000;

      const options = {
        hostname: host,
        port: port,
        path: '/',
        method: 'GET',
        timeout: timeout,
        headers: {
          'User-Agent': 'HA-Tunnel-Discovery/1.0'
        }
      };

      if (protocol === 'https') {
        options.rejectUnauthorized = false; // ÂÖÅËÆ∏Ëá™Á≠æÂêçËØÅ‰π¶
      }

      const req = httpModule.request(options, (res) => {
        let data = '';

        res.on('data', (chunk) => {
          data += chunk.toString();
          // ÈôêÂà∂Êï∞ÊçÆÂ§ßÂ∞è
          if (data.length > 10240) { // 10KB
            req.destroy();
          }
        });

        res.on('end', () => {
          resolve({
            statusCode: res.statusCode,
            headers: res.headers,
            body: data,
            contentType: res.headers['content-type'] || ''
          });
        });
      });

      req.on('error', (error) => {
        reject(error);
      });

      req.on('timeout', () => {
        req.destroy();
        reject(new Error('ËØ∑Ê±ÇË∂ÖÊó∂'));
      });

      req.end();
    });
  }

  /**
   * Âà§Êñ≠ÊòØÂê¶‰∏∫ Home Assistant ÂìçÂ∫î
   */
  isHomeAssistantResponse(response) {
    if (!response || response.statusCode < 200 || response.statusCode >= 500) {
      return false;
    }

    const { headers, body } = response;
    const content = (body || '').toLowerCase();
    const serverHeader = (headers.server || '').toLowerCase();

    // Ê£ÄÊü• HTML ÂÜÖÂÆπ
    const haIndicators = [
      'home assistant',
      'homeassistant',
      'hass-frontend',
      'hassio',
      'supervisor'
    ];

    for (const indicator of haIndicators) {
      if (content.includes(indicator) || serverHeader.includes(indicator)) {
        return true;
      }
    }

    // Ê£ÄÊü•ÁâπÂÆöÁöÑ Home Assistant ÁâπÂæÅ
    if (content.includes('<title>home assistant</title>') ||
      content.includes('app-drawer-layout') ||
      content.includes('home-assistant-main') ||
      headers['x-ha-access'] ||
      content.includes('frontend_latest')) {
      return true;
    }

    return false;
  }

  /**
   * ËÆ°ÁÆóÁΩÆ‰ø°Â∫¶
   */
  calculateConfidence(response) {
    let confidence = 50; // Âü∫Á°ÄÂàÜÊï∞

    const content = (response.body || '').toLowerCase();
    const headers = response.headers || {};

    // Home Assistant ÁâπÂÆöÊ†áËØÜÁ¨¶
    if (content.includes('home assistant')) confidence += 30;
    if (content.includes('hass-frontend')) confidence += 25;
    if (content.includes('home-assistant-main')) confidence += 20;
    if (headers['x-ha-access']) confidence += 20;
    if (content.includes('frontend_latest')) confidence += 15;

    // ÂìçÂ∫îÊó∂Èó¥Âä†ÂàÜ
    if (response.responseTime < 1000) confidence += 10;
    else if (response.responseTime < 3000) confidence += 5;

    // Áä∂ÊÄÅÁ†ÅÊ£ÄÊü•
    if (response.statusCode === 200) confidence += 10;
    else if (response.statusCode === 401) confidence += 5; // ÂèØËÉΩÈúÄË¶ÅËÆ§ËØÅ

    return Math.min(confidence, 100);
  }

  /**
   * ÂéªÈáçÂíåÊéíÂ∫èÁªìÊûú
   */
  deduplicateAndRank(hosts) {
    const hostMap = new Map();

    // ÂéªÈáçÔºå‰øùÁïôÁΩÆ‰ø°Â∫¶ÊúÄÈ´òÁöÑ
    for (const host of hosts) {
      const key = `${host.host}:${host.port}`;
      if (!hostMap.has(key) || hostMap.get(key).confidence < host.confidence) {
        hostMap.set(key, host);
      }
    }

    // ÊåâÁΩÆ‰ø°Â∫¶ÊéíÂ∫è
    return Array.from(hostMap.values()).sort((a, b) => b.confidence - a.confidence);
  }

  /**
   * ÈÄâÊã©ÊúÄ‰Ω≥‰∏ªÊú∫
   */
  selectBestHost(hosts) {
    if (hosts.length === 0) return null;

    // ‰ºòÂÖàÈÄâÊã©ÁΩÆ‰ø°Â∫¶ÊúÄÈ´òÁöÑ
    const bestHost = hosts[0];

    // Â¶ÇÊûúÁΩÆ‰ø°Â∫¶Ë∂≥Â§üÈ´òÔºåÁõ¥Êé•ËøîÂõû
    if (bestHost.confidence >= 80) {
      return bestHost;
    }

    // Âê¶ÂàôÊ£ÄÊü•ÊòØÂê¶ÊúâÊú¨Âú∞‰∏ªÊú∫ÔºàÊõ¥Á®≥ÂÆöÔºâ
    const localHosts = hosts.filter(h =>
      h.host === '127.0.0.1' ||
      h.host === 'localhost' ||
      h.host.startsWith('192.168.') ||
      h.host.startsWith('10.0.') ||
      h.host.startsWith('172.')
    );

    return localHosts.length > 0 ? localHosts[0] : bestHost;
  }

  /**
   * Âà§Êñ≠ÊúçÂä°ÂêçÊòØÂê¶ÂÉè Home Assistant
   */
  isLikelyHomeAssistant(name) {
    if (!name) return false;
    const lowerName = name.toLowerCase();
    return this.haIndicators.some(indicator => lowerName.includes(indicator));
  }

  /**
   * Ëß£Êûê DNS-SD ËæìÂá∫
   */
  parseDNSSDOutput(output) {
    const services = [];
    const lines = output.split('\n');

    for (const line of lines) {
      // ÁÆÄÂçïÁöÑËß£ÊûêÔºåÂÆûÈôÖÂÆûÁé∞ÂèØËÉΩÈúÄË¶ÅÊõ¥Â§çÊùÇÁöÑÈÄªËæë
      if (line.includes('_http._tcp') && (line.includes('homeassistant') || line.includes('hass'))) {
        const parts = line.split(/\s+/);
        if (parts.length > 3) {
          services.push({
            name: parts[3],
            type: '_http._tcp',
            host: 'unknown', // ÈúÄË¶ÅËøõ‰∏ÄÊ≠•Ëß£Êûê
            port: 8123
          });
        }
      }
    }

    return services;
  }

  /**
   * Ëß£Êûê Avahi ËæìÂá∫
   */
  parseAvahiOutput(output) {
    const services = [];
    const lines = output.split('\n');

    for (const line of lines) {
      if (line.includes('_http._tcp') && (line.includes('homeassistant') || line.includes('hass'))) {
        const parts = line.split(/\s+/);
        services.push({
          name: parts[parts.length - 1] || 'unknown',
          type: '_http._tcp',
          host: 'unknown',
          port: 8123
        });
      }
    }

    return services;
  }

  /**
   * Ëé∑ÂèñÁºìÂ≠òÁöÑÂèëÁé∞ÁªìÊûú
   */
  getCachedResults() {
    return Array.from(this.discoveredHosts.values());
  }

  /**
   * Ê∏ÖÈô§ÁºìÂ≠ò
   */
  clearCache() {
    this.discoveredHosts.clear();
    this.scanResults = [];
  }
}

module.exports = HANetworkDiscovery;
